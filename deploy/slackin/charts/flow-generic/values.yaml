nameOverride: ""
fullnameOverride: ""
team: "foundation"

# Container port that the microservice is bound to
service:
  nameOverride: ""
  port: 9000
  httpsPort: null


# Default IAM Role used by all microservices
iamRole: ""


image:
  repository: ""
  pullPolicy: IfNotPresent
  # Container args
  args: "production"

imagePullSecrets:
  - name: flow-docker-hub



# Always define requests == limits, the reason for this is to ensure
# proper scheduling and to avoid any resource conflicts with other
# services on the same node especially with respect to CPU which is a
# compressible resource.
resources: {}
  # limits:
  #   memory: "1300Mi"
  #   cpu: 2
  # requests:
  #   memory: "1300Mi"
  #   cpu: 2


# JAVA_OPTS
jvmOpts:
  enabled: true
  memory: ""
  extraArgs: "-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/dumps/oom.bin -XX:+UseG1GC -XX:+UseStringDeduplication -XX:FlightRecorderOptions=stackdepth=256"

affinity:
  enabled: false
nodeSelector: {}
tolerations: {}
topologySpreadConstraints:
  enabled: true


istioIngress:
  enabled: true
  defaultCFProxy: false
  authorizationPolicy:
    ipBlocks:
      action: ""
      ipList: ""
      # - 10.0.0.1/32
      # - 10.140.0.0/16
      hosts: ""
    dryRun: false
  # The dns flag ensures that the relevant hosts CNAME record is created in
  # Cloudflare automatically.
  gateways: null
    # - key: fdtn-test-stream-flow-io
    #   tld: api.flow.io
    #   dns: true
    #   hosts:
    #     - fdtn-test-stream.api.flow.io
    # - key: fdtn-test-stream-flow-io-alb
    #   tld: api.flow.io
    #   dns: false
    #   hosts:
    #     - fdtn-test-stream.alb.api.flow.io
    # - key: fdtn-test-stream-flow-pub
    #   tld: flo.pub
    #   dns: true
    #   hosts:
    #     - fdtn-test-stream.flo.pub


istioService:
  live:
    hosts: null
      # - fdtn-test-stream
      # - fdtn-test-stream.api.flow.io
      # - fdtn-test-stream.alb.api.flow.io
      # - fdtn-test-stream.flo.pub
    gateways: null
      # - mesh
      # - fdtn-test-stream-flow-io
      # - fdtn-test-stream-flow-io-alb
      # - fdtn-test-stream-flow-pub
    lbAlgorithm: "LEAST_CONN"
    idleTimeoutOverride: true
    idleTimeoutValue: 70s
    stages:
      - deployment: live
        weight: 100

istio:
  logLevel: "info"
  agentLogEnabled: false
  agentLogLevel: "error"
  terminationDrainDuration: 30s
  retries:
    enabled: false
    attempts: 2
    perTryTimeout: 0.5s


deployments:
  live:
    minReplicas: 1
    maxReplicas: 1
    maxUnavailable: 0
    disruptionBudgetEnabled: true
    targetCPUUtilizationPercentage: 80
    version: #from commandline
    strategy: RollingUpdate
    maxSurge: 10%
    serviceAccountName: ""
    serviceAccountIamRole: ""
    sysctlEnabled: false 
    disableAutoscalerEviction: false
    terminationGracePeriodSeconds: 60
    preStophookEnabled: false
    livenessProbeEnabled: true
    globalSecurityContext: {}
      # runAsUser: 999
      # runAsGroup: 999
      # fsGroup: 999
    containerSecurityContext: {}
    #  capabilities:
    #   drop:
    #     - all
    #  readOnlyRootFilesystem: true
    # runAsNonRoot: true

# Argo Rollouts for progressive deploys
rollout:
  enabled: false
  # This flag has to be turned on only during migrations between progressive and non-progressive deploys
  migration: false
  # slack channel for sending the rollout notifications
  notificationChannel: deploys
  # Defines the rollout strategy - canary or blue-green
  strategy: "canary"
  # Dynamically scale the stable/live ReplicaSet according to traffic weight
  enableDynamicScale: false 
  revisionHistoryLimit: 5
  # The maximum time in seconds in which a rollout must make progress during
  # an update, before it is considered to be failed. Argo Rollouts will
  # continue to process failed rollouts and a condition with a
  # ProgressDeadlineExceeded reason will be surfaced in the rollout status.
  # Note that progress will not be estimated during the time a rollout is
  # paused.
  progressDeadlineSeconds: 900
  # Whether to abort the update when ProgressDeadlineSeconds is exceeded.
  progressDeadlineAbort: true
  # Analysis steps for subset level traffic splitting across versions.
  steps:
    - setWeight: 15
    - pause:
        duration: 60
    - setWeight: 30
    - pause:
        duration: 60
    - setWeight: 60
    - pause:
        duration: 60
  
  defaultAnalysis: {}
  jobAnalysis: {}
  # This can have multiple datadog metrics block.
  # Handle empty query results yielding a nil value via default()
  # analysis:
  # - name: error-rate
  #   interval: 1m
  #   successCondition: default(result, 0) < 0.05
  #   failureLimit: 0
  #   provider:
  #     datadog:
  #       interval: 1m
  #       query: |
  #         sum:trace.akka_http.request.errors{service:fdtn-test,cluster_name:flow-prod-eks}.as_count() /
  #         sum:trace.akka_http.request.hits{service:fdtn-test,cluster_name:flow-prod-eks}.as_count()
  # - name: response-time
  #   interval: 1m
  #   successCondition: default(result, 0) < 0.0015
  #   failureLimit: 0
  #   provider:
  #     datadog:
  #       interval: 1m
  #       query: p95:trace.akka_http.request{service:fdnt-test}

  # Delay starting analysis run until step 1
  analysisStartingStep: 1

# Datadog monitors generated using Datadog operator
datadogMonitors: null
  # - type: trace.akka_http.request.errors-sum
  #   interval: last_10m
  #   alert:
  #     threshold: "100"
  #     notificationTarget: "@email@example.com"
  #   warning:
  #     threshold: "50"
  #     notificationTarget: "@slack-test"
